// Generated by CoffeeScript 1.6.3
(function() {
  var ACCUR, Basic, C, Cam, Css, FreeFall, Handler, Image, Lg, Line, Log, Map, Mixin, Parabola, Queue, T, Track, U, Vam, getTrack, spreader, _math, _ref, _util,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ACCUR = 6;

  _math = {
    isInt: function(x) {
      return x === parseInt(x);
    },
    isOdd: function(x) {
      return !this.isInt(x / 2);
    },
    getAccuracy: function(num) {
      var _ref;
      return ((_ref = (num + '').split('.')[1]) != null ? _ref.length : void 0) || 0;
    },
    beAccuracy: function(num, accur) {
      var curAccur, k, res;
      accur = accur || ACCUR;
      curAccur = this.getAccuracy(num);
      if (curAccur <= accur) {
        res = num;
      } else {
        k = this.power(10, accur);
        res = Math.round(num * k) / k;
      }
      return res;
    },
    power: function(x, n, accuracy) {
      var bA, isInt, isRec, isSqrt, res;
      res = x;
      isInt = this.isInt;
      bA = this.beAccuracy;
      isRec = false;
      isSqrt = false;
      if (n === 0) {
        return 1;
      }
      if (n < 0) {
        isRec = true;
        n = Math.abs(n);
      }
      if (!isInt(n) && isInt(2 * n)) {
        n = n * 2;
        isSqrt = true;
      }
      if (!isInt(2 * n)) {
        n = parseInt(n);
      }
      while (--n > 0) {
        res = res * x;
      }
      if (isSqrt) {
        res = bA(Math.sqrt(res));
      }
      if (isRec) {
        res = bA(1 / res);
      }
      return res;
    },
    getDeg: function(sin, cos) {
      var bA, degC, degS, p, res, _degC, _degS, _ref;
      bA = this.beAccuracy;
      degS = Math.asin(sin) * 180 / Math.PI;
      degC = Math.acos(cos) * 180 / Math.PI;
      _degS = (_ref = degS >= 0) != null ? _ref : 180 - {
        degS: -degS - 180
      };
      _degC = -degC;
      p = parseInt;
      if ((p(degS) === p(degC)) || (p(degS) === p(_degC))) {
        res = degS;
      } else {
        res = _degS;
      }
      return bA(res);
    },
    getUnit: function(arr) {
      var match, reg, res, str, unit, _i, _len;
      if (!$.isArray(arr)) {
        arr = [arr];
      }
      res = false;
      unit = function(val) {
        return val;
      };
      match = false;
      reg = /[\d|.]+/g;
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        str = arr[_i];
        if (typeof str === 'string') {
          str.replace(reg, function(match) {
            match = true;
            return '{num}';
          });
          if (match && str.length > 5) {
            res = str;
            break;
          }
        }
      }
      if (res) {
        unit = function(num) {
          return res.replace('{num}', num);
        };
      }
      return unit;
    },
    withOutUnit: function(arr) {
      var reg, res;
      res = [];
      reg = /[a-zA-Z]+/g;
      if (!$.isArray(arr)) {
        arr = [arr];
      }
      $.each(arr, function(index, item) {
        if (!item) {
          item = 0;
        } else {
          item = (typeof item.replace === "function" ? item.replace(reg, '') : void 0) || item;
        }
        return res.push(+item);
      });
      return res;
    },
    identity: function(val) {
      return val;
    },
    compact: function(arr) {
      var item, res, _i, _len;
      res = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        item = arr[_i];
        if (this.identity(item)) {
          res.push(item);
        } else {
          res.push(0);
        }
      }
      return res;
    },
    awu: function(type) {
      var args, item, res, step, unit;
      args = [].slice.call(arguments, 1);
      args = this.compact(args);
      unit = this.getUnit(args);
      args = this.withOutUnit(args);
      switch (type) {
        case '+':
          step = function(a, b) {
            return a + b;
          };
          break;
        case '-':
          step = function(a, b) {
            return a - b;
          };
          break;
        case '*':
          step = function(a, b) {
            return a * b;
          };
          break;
        case '/':
          step = function(a, b) {
            return a / b;
          };
          break;
      }
      res = args.shift();
      while (args.length) {
        item = args.shift();
        res = step(res, item);
      }
      return unit(res);
    }
  };

  _util = {
    cCtr: function(ctor, statics) {
      $.extend(ctor.prototype, statics);
      return ctor;
    },
    getArrSum: function(arr, n) {
      var i, sum;
      i = 0;
      sum = 0;
      while (i < n) {
        sum += arr[i];
        i++;
      }
      return sum;
    },
    getSumArr: function(arr) {
      var len, ts;
      ts = [];
      len = arr.length;
      while (len) {
        ts[len - 1] = this.getSum(arr, len);
        len--;
      }
      return ts;
    },
    getSum: function(arr, n) {
      var a, i, res, _i, _len;
      res = 0;
      n = n || arr.length;
      for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
        a = arr[i];
        if (i < n) {
          res += a;
        }
      }
      return res;
    },
    firstLetterUpper: function(str) {
      return str.replace(/^[a-z]{1}/, function(match) {
        return match.toUpperCase();
      });
    },
    firstLetterLower: function(str) {
      return str.replace(/^[a-z]{1}/, function(match) {
        return match.toLowerCase();
      });
    }
  };

  Map = (function() {
    function Map(opts) {
      this._data = opts.data || {};
      this._root = opts.root || window;
      this.defaultDomain = opts.defaultDomain || 'Custom';
      this;
    }

    Map.prototype.set = function() {
      var func;
      switch (typeof arguments[0]) {
        case 'string':
          func = '_set';
          break;
        default:
          func = '_setObj';
      }
      return this[func].apply(this, arguments);
    };

    Map.prototype._setObj = function(obj, domain) {
      var key, value;
      for (key in obj) {
        value = obj[key];
        this._set(key, value, domain);
      }
      return this;
    };

    Map.prototype._set = function(name, ctor, domain) {
      var arr, root, target, _name;
      domain = domain || this.defaultDomain;
      name = "" + domain + "." + name;
      _name = '';
      name = name.replace(/[a-zA-Z]+$/, function(match) {
        _name = U.firstLetterLower(match);
        return U.firstLetterUpper(match);
      });
      this._data[_name] = name;
      arr = name.split('.');
      target = arr.pop();
      root = this._root;
      while ((name = arr.shift())) {
        if (!root[name]) {
          root[name] = {};
        }
        root = root[name];
      }
      if (root[target]) {
        this.onError("namespace conflict at " + target);
      }
      root[target] = ctor;
      return this;
    };

    Map.prototype.get = function(name) {
      var arr, ctor;
      name = U.firstLetterLower(name);
      arr = this._data[name].split('.');
      ctor = this._root;
      while ((name = arr.shift())) {
        ctor = ctor[name];
      }
      return ctor;
    };

    Map.prototype.onError = function(msg) {
      return console.log(msg);
    };

    return Map;

  })();

  Queue = (function() {
    function Queue(opts) {
      this._q = {};
      this._order = [];
      this;
    }

    Queue.prototype.find = function(name) {
      return name && this._q[name];
    };

    Queue.prototype.push = function(name, func) {
      var args, exist;
      args = [].slice.call(arguments, 2);
      exist = this.find(name);
      if (exist) {
        if (exist.length === 2 && typeof exist[1] === 'object' && args.length === 1 && typeof args[0] === 'object') {
          return exist[1] = $.extend({}, exist[1], args[0]);
        } else {
          return exist.concat(args);
        }
      } else {
        this._order.push(name);
        args.unshift(func);
        return this._q[name] = args;
      }
    };

    Queue.prototype.next = function() {
      var callback, handle, name,
        _this = this;
      callback = function() {
        return _this.next();
      };
      if (this._order.length) {
        name = this._order.shift();
        handle = this.find(name);
        if (handle) {
          handle.push(callback);
          handle.shift().apply(null, handle);
          return this["delete"](name);
        } else {
          return this.next();
        }
      }
    };

    Queue.prototype["delete"] = function(name) {
      return delete this._q[name];
    };

    return Queue;

  })();

  U = $.extend({}, _math, _util, {
    Map: Map,
    Queue: Queue
  });

  Image = (function() {
    function Image(opts) {
      this.opts = opts = opts || {};
      this._i = opts.interval || [0, Infinity];
      this._offX = this._i[0];
      this._t = this._i[1];
      this._r = opts.reverse;
      this.opts.type = this.opts.type || 'stop';
    }

    Image.prototype.getLast = function() {
      var ins;
      if (this.insArr) {
        ins = this.insArr[this.insArr.length - 1];
      } else {
        ins = this;
      }
      return ins;
    };

    Image.prototype.isOnEnd = function(x) {
      return this._t && x > this._t;
    };

    Image.prototype._checkT = function(x, method) {
      if (this.isOnEnd(x)) {
        return this._check(x, method);
      } else {
        return false;
      }
    };

    Image.prototype._check = function(x, method) {
      var cT, ins, p, times, _ref, _ref1, _ref2;
      switch (this.opts.type) {
        case 'stay':
          return this[method](this._t);
        case 'circle':
        case 'circle-last':
          cT = x - this._t;
          ins = this.getLast();
          cT = cT % ins._t;
          return this[method](cT);
        case 'circle-all':
          cT = U.beAccuracy(x % this._t, 2);
          return this[method](cT);
        case 'decay':
        case 'decay-last':
          p = ((_ref = this.opts.data) != null ? _ref.decay : void 0) || 2;
          x = x - this._t;
          ins = this.getLast();
          cT = x % ins._t;
          times = parseInt(x / ins._t);
          if (times > (this.decay_times || 0)) {
            this.a = U.beAccuracy(this.a / p, 2);
            this.decay_times = times;
          }
          return this[method](cT);
        case 'decay-all':
          p = ((_ref1 = this.opts.data) != null ? _ref1.decay : void 0) || 2;
          ins = this;
          cT = x % ins._t;
          times = parseInt(x / ins._t);
          if (times > (this.decay_times || 0)) {
            this.a = U.beAccuracy(this.a / p, 2);
            this.decay_times = times;
          }
          return this[method](cT);
        case 'decay-t':
          p = ((_ref2 = this.opts.data) != null ? _ref2.decay : void 0) || 1.2;
          cT = x % this._t;
          times = parseInt(x / this._t);
          this._decay = U.power(0.8, times);
          return this[method](cT);
        default:
          return 0;
      }
    };

    Image.prototype.getY = function(x) {
      var res;
      res = this._checkT(x, 'getY');
      if (res !== false) {
        return res;
      } else {
        if (this._r) {
          return this._getYR(x);
        } else {
          return this._getY(x);
        }
      }
    };

    Image.prototype.getBaseLine = function(type) {
      var ins, isDecay, name, res, _i, _len, _ref;
      type = type.toUpperCase();
      name = 'baseline' + type;
      isDecay = /decay/.test(this.opts.type);
      if (this[name]) {
        if (isDecay) {
          return U.power(2, this.decay_times || 0) * this[name];
        } else {
          return this[name];
        }
      }
      if (this.opts[name]) {
        this[name] = this.opts[name];
        if (isDecay) {
          return U.power(2, this.decay_times || 0) * this[name];
        } else {
          return this[name];
        }
      } else {
        if (this.insArr) {
          res = [];
          _ref = this.insArr;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            ins = _ref[_i];
            res.push(ins.getBaseLine(type));
          }
          this[name] = Math.max.apply(Math, res);
        } else {
          this[name] = this['get' + type](this._t);
        }
      }
      return this[name];
    };

    Image.prototype.getYp = function(x) {
      var res, s, _endY;
      s = this.getY(x);
      _endY = this.getBaseLine('Y');
      res = s / _endY;
      if (this._decay) {
        res = U.beAccuracy(res * this._decay);
      }
      return res;
    };

    Image.prototype.getS = function(x) {
      var res;
      res = this._checkT(x, 'getS');
      if (res !== false) {
        return res;
      } else {
        if (this._r) {
          return this._getSR(x);
        } else {
          return this._getS(x);
        }
      }
    };

    Image.prototype.getSp = function(x) {
      var res, s, _endS;
      s = this.getS(x);
      _endS = this.getBaseLine('S');
      res = s / _endS;
      if (this._decay) {
        res = U.beAccuracy(res * this._decay);
      }
      return res;
    };

    Image.prototype._getYR = function(x) {
      if (this._t === Infinity) {
        return 0;
      } else {
        return this._getY(this._t - x);
      }
    };

    Image.prototype._getSR = function(x) {
      return this._getS(this._t) - this._getS(this._t - x);
    };

    return Image;

  })();

  Parabola = (function(_super) {
    __extends(Parabola, _super);

    function Parabola(opts) {
      Parabola.__super__.constructor.apply(this, arguments);
      this.a = opts.a;
      this.b = opts.b;
      this;
    }

    Parabola.prototype._getY = function(x) {
      x += this._offX;
      return this.a * U.power(x, 2) + this.b;
    };

    Parabola.prototype._getS = function(x) {
      x += this._offX;
      return this.a * U.power(x, 3) / 3 + this.b * x;
    };

    return Parabola;

  })(Image);

  Log = (function(_super) {
    __extends(Log, _super);

    function Log(opts) {
      Log.__super__.constructor.apply(this, arguments);
      this.a = opts.a;
      this.b = opts.b;
      this.p = opts.p;
      this;
    }

    Log.prototype._getY = function(x) {
      return this.a * Math.log(x) / Math.log(this.p) + this.b;
    };

    Log.prototype._getS = function(x) {
      return 0;
    };

    return Log;

  })(Image);

  Lg = (function(_super) {
    __extends(Lg, _super);

    function Lg(opts) {
      Lg.__super__.constructor.apply(this, arguments);
      this.p = 10;
      this;
    }

    return Lg;

  })(Log);

  Line = (function(_super) {
    __extends(Line, _super);

    function Line(opts) {
      Line.__super__.constructor.apply(this, arguments);
      this.a = opts.a;
      this.b = opts.b;
      this;
    }

    Line.prototype._getY = function(x) {
      x += this._offX;
      return this.a * x + this.b;
    };

    Line.prototype._getS = function(x) {
      x += this._offX;
      return this.a * x * x / 2 + this.b * x;
    };

    return Line;

  })(Image);

  Vam = (function(_super) {
    __extends(Vam, _super);

    function Vam(opts) {
      var s, t, v0, vt;
      v0 = opts.v0;
      vt = opts.vt;
      t = opts.t;
      s = opts.s;
      opts.a = (vt - v0) / (t * t);
      opts.b = v0;
      Vam.__super__.constructor.apply(this, arguments);
      this;
    }

    return Vam;

  })(Parabola);

  Cam = (function(_super) {
    __extends(Cam, _super);

    function Cam(opts) {
      opts.a = (opts.vt - opts.v0) / opts.t;
      opts.b = opts.v0;
      Cam.__super__.constructor.apply(this, arguments);
      this;
    }

    return Cam;

  })(Line);

  Mixin = (function(_super) {
    __extends(Mixin, _super);

    function Mixin() {
      _ref = Mixin.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Mixin.prototype._getPos = function(x) {
      var arr, i, res;
      arr = this.tArr;
      i = arr.length;
      res = 0;
      while (i--) {
        if (x > arr[i]) {
          res = i + 1;
          break;
        }
      }
      return res;
    };

    Mixin.prototype.getY = function(x) {
      var iss, pos, res, ts;
      res = this._checkT(x, 'getY');
      if (res !== false) {
        return res;
      } else {
        pos = this._getPos(x);
        ts = this.tArr;
        iss = this.insArr;
        x -= ts[pos - 1] || 0;
        res = iss[pos].getY(x);
        return res;
      }
    };

    Mixin.prototype.getS = function(x) {
      var pos, res, sArr;
      res = this._checkT(x, 'getS');
      if (res !== false) {
        return res;
      } else {
        pos = this._getPos(x);
        sArr = this._getSArr();
        res = sArr[pos - 1] || 0;
        x -= this.tArr[pos - 1] || 0;
        res += this.insArr[pos].getS(x);
        return res;
      }
    };

    Mixin.prototype._getSArr = function() {
      var i, iss, ss, t, ts, _i, _len;
      if (this.sArr) {
        return this.sArr;
      }
      ts = this.tArr;
      iss = this.insArr;
      ss = [];
      for (i = _i = 0, _len = ts.length; _i < _len; i = ++_i) {
        t = ts[i];
        ss.push(iss[i].getS(ts[i] - (ts[i - 1] || 0)));
      }
      ss = U.getSumArr(ss);
      this.sArr = ss;
      return ss;
    };

    return Mixin;

  })(Image);

  T = Track = {
    mix: function(arr, opts) {
      var X, insArr, map;
      insArr = [];
      map = this.map;
      $.each(arr, function(index, item) {
        var Ctor, name, options;
        name = item[0];
        options = item[1];
        Ctor = map.get(name);
        return Ctor && insArr.push(new Ctor(options));
      });
      X = (function(_super) {
        __extends(X, _super);

        function X(opts, tArr) {
          var i, ins, _i, _j, _len, _len1;
          X.__super__.constructor.apply(this, arguments);
          this.insArr = insArr = this._insArr.slice();
          if (tArr) {
            this.tArr = tArr;
            for (i = _i = 0, _len = insArr.length; _i < _len; i = ++_i) {
              ins = insArr[i];
              ins._t = this.tArr[i];
            }
          } else {
            this.tArr = [];
            for (_j = 0, _len1 = insArr.length; _j < _len1; _j++) {
              ins = insArr[_j];
              this.tArr.push(ins._t);
            }
          }
          this._t = U.getSum(this.tArr);
          this.tArr = U.getSumArr(this.tArr);
          this;
        }

        X.prototype._insArr = insArr;

        return X;

      })(Mixin);
      return X;
    },
    push: function() {
      return this.map.set.apply(this.map, arguments);
    },
    extend: function() {
      var args;
      args = arguments;
      if ($.isArray(args[1])) {
        return this._extendMixin.apply(this, args);
      } else {
        return this._extendBasic.apply(this, args);
      }
    },
    _extendMixin: function(name, arr, opts) {
      return this.push(name, this.mix(opts, arr));
    },
    _extendBasic: function(name, ctor, statics, parent) {
      var Pnt, X, _class, _ref1;
      if (parent) {
        parent = parent.toLowerCase();
        Pnt = this.map.get(parent);
      } else {
        Pnt = Image;
      }
      X = (function(_super) {
        __extends(X, _super);

        function X() {
          _ref1 = _class.apply(this, arguments);
          return _ref1;
        }

        _class = ctor;

        return X;

      })(Pnt);
      $.extend(X.__super__, statics);
      return this.push(name, X);
    }
  };

  Track.map = new U.Map({
    root: Track
  });

  Track.push({
    'line': Line,
    'parabola': Parabola,
    'log': Log,
    'lg': Lg
  }, 'Math');

  Track.push({
    'vam': Vam,
    'cam': Cam
  }, 'Physics');

  FreeFall = (function(_super) {
    __extends(FreeFall, _super);

    function FreeFall(opts) {
      this.opts = opts || {};
      FreeFall.__super__.constructor.apply(this, arguments);
      this.v0 = opts.v0;
      this.a = 5;
      this.b = 0;
      this.c = 0;
      this._derec = 0;
      this.opts.type = 'decay';
      this.ym = opts.ym;
      this.times = 1;
      if (opts.times) {
        this.ym /= opts.times;
        this.times = opts.times;
      }
      this._t = U.beAccuracy(Math.sqrt(this.ym / 5), 2);
      this._sumT = 0;
    }

    FreeFall.prototype.isOnEnd = function(x) {
      if (this._sumT) {
        return x > this._sumT;
      } else {
        return x > this._t;
      }
    };

    FreeFall.prototype._check = function(x, method) {
      var p, vt, _ref1;
      switch (this.opts.type) {
        case 'decay':
          if (this._t < 0.01) {
            return this.ym * this.times;
          }
          p = ((_ref1 = this.opts.data) != null ? _ref1.decay : void 0) || 0.8;
          x -= this._sumT;
          if (x > this._t) {
            this._derec = ++this._derec % 2;
            this._sumT += this._t;
            x -= this._t;
            if (this._derec) {
              vt = 10 * this._t * p;
              this.a = 5;
              this.b = -vt;
              this.c = this.ym;
              this._t = vt / 10;
              this.yn = vt * vt / 20;
            } else {
              this.b = 0;
              this.a = 5;
              this.c = this.ym - this.yn;
            }
          }
          return this[method](x);
      }
      return FreeFall.__super__._check.apply(this, arguments);
    };

    FreeFall.prototype._getY = function(x) {
      return (this.a * x * x + this.b * x + this.c) * this.times;
    };

    FreeFall.prototype.getX = function(x) {
      return (this.v0 * x) * this.times;
    };

    return FreeFall;

  })(Image);

  T.push('freeFall', FreeFall);

  Basic = (function() {
    function Basic() {}

    Basic.prototype._map = {};

    Basic.prototype.isCustom = function(name) {
      return !!this._map[name];
    };

    Basic.prototype.getHandler = function(name) {
      return this._map[name];
    };

    Basic.prototype._getC = function(dom, name) {
      var handler;
      handler = this.getHandler(name);
      return handler.get.call(this, dom, name);
    };

    Basic.prototype._setC = function(dom, name, value) {
      var data, handler, id,
        _this = this;
      handler = this.getHandler(name);
      if (handler.related) {
        id = handler._id;
        (data = {})[name] = value;
        return this.queue.push(id, function(data) {
          return handler.set.call(_this, dom, data);
        }, data);
      } else {
        data = {};
        data[name] = value;
        return handler.set.call(this, dom, data);
      }
    };

    Basic.prototype.gcc = function(prop) {
      var div, prefix, prefixes, sty, vendor, _i, _len, _prop;
      div = document.createElement('div');
      sty = div.style;
      if (sty[prop] !== void 0) {
        return prop;
      }
      prefixes = ['Moz', 'webkit', 'O', 'ms'];
      _prop = U.firstLetterUpper(prop);
      for (_i = 0, _len = prefixes.length; _i < _len; _i++) {
        prefix = prefixes[_i];
        vendor = prefix + _prop;
        if (sty[vendor] !== void 0) {
          return vendor;
        }
      }
      return false;
    };

    Basic.prototype.extend = function(cCss, funcs) {
      var a, arr, name, _i, _id, _len;
      if ($.isArray(cCss)) {
        arr = cCss;
      } else if (typeof cCss === 'object') {
        arr = [];
        for (name in cCss) {
          arr.push(name);
        }
      } else {
        arr = [cCss];
      }
      _id = arr.join('0');
      funcs._id = _id;
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        a = arr[_i];
        this._map[a] = funcs;
      }
      return this;
    };

    return Basic;

  })();

  spreader = new Basic();

  Handler = (function(_super) {
    __extends(Handler, _super);

    function Handler(css, dom, opts) {
      var $dom;
      this.$dom = $dom = $(dom);
      this.initOriginCss(css);
      this._css = css;
      this.queue = new U.Queue();
      this.initStep();
      this;
    }

    Handler.prototype.initOriginCss = function(css) {
      var $d, C, va, _i, _len, _results, _results1;
      $d = this.$dom;
      C = Css;
      this._o = {};
      if ($.isArray(css)) {
        _results = [];
        for (_i = 0, _len = css.length; _i < _len; _i++) {
          va = css[_i];
          _results.push(this._o[va] = this.get(va));
        }
        return _results;
      } else if (typeof css === 'object') {
        _results1 = [];
        for (va in css) {
          _results1.push(this._o[va] = this.get(va));
        }
        return _results1;
      } else {
        return this.onError('type error in initOriginCss');
      }
    };

    Handler.prototype.initStep = function() {
      var endC, startC,
        _this = this;
      endC = this._css;
      startC = this._o;
      return this.step = function(p) {
        var va, _cur;
        _cur = {};
        for (va in endC) {
          _cur[va] = U.awu('-', endC[va], startC[va]);
          _cur[va] = U.awu('*', _cur[va], p);
          _cur[va] = U.awu('+', _cur[va], startC[va]);
        }
        return _this.set(_cur);
      };
    };

    Handler.prototype.get = function(name) {
      return this._attr('get', name);
    };

    Handler.prototype.set = function(css) {
      var key, value;
      for (key in css) {
        value = css[key];
        this._attr('set', key, value);
      }
      return this.queue.next();
    };

    Handler.prototype._attr = function(method, name, value) {
      var args, cc;
      args = [].slice.call(arguments, 1);
      if ((cc = this.gcc(name))) {
        return this.$dom.css.apply(this.$dom, args);
      } else if (this.isCustom(name)) {
        args.unshift(this.$dom);
        return this['_' + method + 'C'].apply(this, args);
      } else {

      }
    };

    return Handler;

  })(Basic);

  Css = C = {
    handle: function(css, dom, opts) {
      return new Handler(css, dom, opts);
    },
    spreadCss: function(cCss, funcs) {
      return spreader.extend(cCss, funcs);
    }
  };

  C.spreadCss(['rotate', 'translate', 'scale'], {
    related: true,
    get: function($dom, type) {
      var a, b, c, cos, cssName, d, deg, e, f, matri, matrix, res, sin, sx, sy, x, y;
      cssName = this.gcc('transform');
      matrix = $dom.css(cssName);
      if (/\d+/.test(matrix)) {
        matri = [];
        matrix.replace(/[\d.]+/g, function(match) {
          matri.push(+match);
          return match;
        });
        a = matri[0];
        b = matri[1];
        c = matri[2];
        d = matri[3];
        e = matri[4];
        f = matri[5];
        sx = Math.sqrt(a * a + b * b);
        sy = Math.sqrt(c * c + d * d);
        sin = c / sy;
        cos = a / sx;
        deg = U.getDeg(sin, cos);
        y = f * cos / sy - e * sin / sx;
        x = (e / sx + y * sin) / cos;
        res = {
          rotate: deg,
          translate: x + ',' + y,
          scale: sx + ',' + sy
        };
      } else {
        res = {
          rotate: 0,
          translate: '0,0',
          scale: '0,0'
        };
      }
      if (type) {
        return res[type];
      } else {
        return res;
      }
    },
    set: function($dom, css, callback) {
      var a, arr, b, c, cos, cs, cssName, d, e, f, rad, res, sin, sx, sy, va, x, y;
      cssName = this.gcc('transform');
      sx = 1;
      sy = 1;
      sin = 0;
      rad = 0;
      cos = 1;
      x = 0;
      y = 0;
      for (va in css) {
        cs = css[va];
        switch (va) {
          case 'rotate':
            rad = +cs * Math.PI / 180;
            sin = Math.sin(rad);
            cos = Math.cos(rad);
            break;
          case 'translate':
            arr = cs.split(',');
            x = +arr[0];
            y = +arr[1];
            break;
          case 'scale':
            arr = cs.split(',');
            sx = +arr[0];
            sy = +arr[1];
            break;
        }
      }
      a = sx * cos;
      b = -sx * sin;
      c = sy * sin;
      d = sy * cos;
      e = sx * (x * cos - y * sin);
      f = sy * (x * sin + y * cos);
      res = {};
      res[cssName] = 'matrix(' + [a, b, c, d, e, f].join(',') + ')';
      if ($dom != null) {
        $dom.css(res);
      }
      if (typeof callback === "function") {
        callback();
      }
      return res;
    }
  });

  getTrack = function(track, opts) {
    var ctor;
    if (typeof track === 'string') {

    } else if ($.isArray(track)) {
      if ($.isArray(track[0])) {
        ctor = T.mix(track, opts);
        track = new ctor(opts);
      } else {
        opts = $.extend({}, opts, track[1]);
        ctor = T.map.get(track[0]);
        track = new ctor(opts);
      }
    }
    return track;
  };

  $.fn.motion = function(css, track, callback, opts) {
    opts = opts || {};
    track = getTrack(track, opts);
    return $(this).each(function(ind, dom) {
      var handler, step, t, timer;
      if ($.isFunction(css)) {
        step = css;
      } else {
        handler = C.handle(css, $(dom));
        step = handler.step;
      }
      t = 0;
      return timer = setInterval(function() {
        var p;
        p = track.getSp(t);
        if (t && !track.getY(t) && track.opts.type === 'stop') {
          clearInterval(timer);
          $(dom).animating = false;
          return callback();
        }
        step(p, track, t);
        if (typeof opts.step === "function") {
          opts.step(p);
        }
        return t = U.beAccuracy(t + 0.04, 2);
      }, 40);
    });
  };

  $.fn.move = function(track, callback, opts) {
    opts = opts || {};
    track = getTrack(track, opts);
    return $(this).each(function(ind, dom) {
      var o, step, stop, t, timer;
      o = $(dom).offset();
      step = function(x, y) {
        return $(dom).css({
          left: o.left + x + 'px',
          top: o.top + y + 'px'
        });
      };
      stop = opts.stop;
      t = 0;
      return timer = setInterval(function() {
        var x, y;
        x = track.getX(t);
        y = track.getY(t);
        if (stop(x, y, t)) {
          clearInterval(timer);
          $(dom).animating = false;
          return callback();
        }
        step(x, y, track);
        if (typeof opts.step === "function") {
          opts.step(x, y, track);
        }
        return t = U.beAccuracy(t + 0.04, 2);
      }, 40);
    });
  };

}).call(this);
