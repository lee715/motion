// Generated by CoffeeScript 1.6.3
(function() {
  define(['../function/copyWithContext', '../promise/type', '../event', '../array/slice'], function(copy, type, Event, slice) {
    var Controller, Events;
    Events = {};
    Controller = (function() {
      function Controller(opts) {
        opts = opts || {};
        this.interval = opts.interval || 20;
        this.status = 'initialize';
        if (opts.events) {
          Events = $.extend(Events, opts.events);
        }
      }

      Controller.prototype.current = function() {
        var now, t, tCircle, tCosted, times, total;
        tCircle = this.timeCircle += this.interval;
        tCosted = this.timeCosted += this.interval;
        total = this.total;
        t = this.t;
        if (tCosted > this.total * 1000) {
          console.log(tCosted, this.total * 1000);
          return this.end();
        }
        if (this._reverse && t !== Infinity) {
          if (total === Infinity) {
            total = t;
          }
          now = total - tCircle / 1000;
        } else {
          now = tCircle / 1000;
        }
        if (now > t) {
          times = parseInt(now / t);
          now = util.beAccuracy(now % t, 2);
          this.fix && this.fix(times);
        }
        return now;
      };

      Controller.prototype.triggerCE = function() {
        var args, evs, func, name, _results;
        args = slice.call(arguments, 0);
        evs = Events;
        _results = [];
        for (name in evs) {
          func = evs[name];
          if (func.apply(null, args)) {
            args.unshift(name);
            _results.push(this.trigger.apply(this, args));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      Controller.prototype.promise = function(res) {
        res = {};
        copy(res, this, 'stop on end back restart repeat toEnd destory percent reverse step toSecond');
        return res;
      };

      Controller.prototype["switch"] = function(status) {
        var _status;
        _status = this.status;
        this.status = status;
        return this.trigger('switch', status, _status);
      };

      Controller.prototype.destory = function() {
        clearInterval(this.timer);
        return delete this;
      };

      Controller.prototype.stop = function() {
        if (this.status === 'moving') {
          return this["switch"]('stop');
        }
      };

      Controller.prototype.reverse = function() {
        if (this.stopOrInit()) {
          return this._reverse = !this._reverse;
        }
      };

      Controller.prototype.stopOrInit = function() {
        return ~'stop initialize'.indexOf(this.status);
      };

      Controller.prototype.restart = function() {
        if (this.stopOrInit()) {
          this["switch"]('moving');
          this.trigger('restart');
          return this.start();
        }
      };

      Controller.prototype.repeat = function() {
        if (this.status === 'end') {
          this["switch"]('moving');
          this.timeCircle = 0;
          return this.start();
        }
      };

      Controller.prototype.back = function() {
        this.stop();
        this.timeCircle = 0;
        this.timeCosted = 0;
        this.trigger('progress', 0);
        return this.trigger('back');
      };

      Controller.prototype.reversible = function() {
        if (this.t !== Infinity) {
          if (this.total === Infinity) {
            this.total = this.t;
          }
          return true;
        } else {
          return false;
        }
      };

      Controller.prototype.percent = function(p) {
        if (this.reversible()) {
          this.timeCircle = parseInt(p * this.total * 1000) - this.interval;
          return this._step(true);
        }
      };

      Controller.prototype.toSecond = function(t) {
        if (t <= this.total && this.reversible()) {
          this.timeCircle = t * 1000 - this.interval;
          this.timeCosted = t * 1000 - this.interval;
          return this._step(true);
        } else {
          return this.toEnd();
        }
      };

      Controller.prototype.toEnd = function() {
        if (this.reversible()) {
          this.timeCircle = this.total * 1000 - this.interval;
          this._step();
        }
        return this.end();
      };

      Controller.prototype.end = function() {
        clearInterval(this.timer);
        this["switch"]('end');
        return this.trigger('done');
      };

      return Controller;

    })();
    $.extend(Controller.prototype, Event);
    return Controller;
  });

}).call(this);
