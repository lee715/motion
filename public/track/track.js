// Generated by CoffeeScript 1.6.3
(function() {
  define(['../graphic/factory', './mix', '../array/slice', '../array/str2arr', '../filter/filter', '../filter/add', '../function/copyWithContext', '../promise/type', '../event'], function(F, Mix, slice, str2arr, filter, add, copy, type, Event) {
    var Track, track;
    Track = (function() {
      function Track(gpc, opts) {
        var bl, fil;
        this.opts = opts = opts || {};
        this.gpc = gpc;
        this.timeCosted = opts.delay && opts.delay * 1000 || 0;
        this.status = 'initialize';
        this.t = opts.t || gpc.t || Infinity;
        this.baseline = bl = opts.baseline || gpc.getS(this.t);
        this.endType = opts.endType || gpc.endType || 'stop';
        if (!(fil = opts.filter)) {
          fil = [[], []];
        }
        fil[0] = str2arr(fil[0]);
        fil[0] = fil[0].concat(['translate', 'decay', 'beforeEnd']);
        fil[1].push(function(p) {
          return this.translate(p);
        });
        fil[1].push(function(p) {
          var i, k, _i, _len;
          for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
            k = this[i];
            this[i] *= p;
          }
          return this;
        });
        fil[1].push(function() {
          var i, k, _i, _len;
          for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
            k = this[i];
            this[i] /= bl;
          }
          return this;
        });
        this.filter = filter.apply(null, fil);
        this.filter.beforeEnd(1);
        opts.autoStart && this.start();
      }

      Track.prototype.reverse = false;

      Track.prototype.promise = function() {
        var res;
        res = {};
        copy(res, this, 'stop restart start repeat on toEnd destory');
        copy(res, this.filter);
        return res;
      };

      Track.prototype.start = function() {
        var m,
          _this = this;
        this.status = 'moving';
        this.timer = m = setInterval(function() {
          _this.step();
          if (_this.timeCosted >= _this.t * 1000) {
            return _this.onEnd(m);
          }
        }, 20);
        return this;
      };

      Track.prototype.destory = function() {
        clearInterval(this.timer);
        return delete this;
      };

      Track.prototype.step = function() {
        var now, val;
        if (this.status === 'stop') {
          return clearInterval(this.timer);
        }
        this.timeCosted += 20;
        if (this.reverse) {
          now = this.t - this.timeCosted / 1000;
        } else {
          now = this.timeCosted / 1000;
        }
        val = this.gpc.getS(now);
        val = this.filter.filter([val])[0];
        return this.trigger('progress', val);
      };

      Track.prototype.stop = function() {
        if (this.status === 'moving') {
          return this.status = 'stop';
        }
      };

      Track.prototype.restart = function() {
        if (this.status === 'stop' || this.status === 'initialize') {
          this.status = 'moving';
          return this.start();
        }
      };

      Track.prototype.repeat = function() {
        if (this.status === 'end') {
          this.status = 'moving';
          this.timeCosted = 0;
          return this.start();
        }
      };

      Track.prototype.toEnd = function() {
        if (this.endType === 'stop') {
          this.timeCosted = this.t * 1000 - 20;
          this.step();
          return this.end();
        }
      };

      Track.prototype.end = function() {
        clearInterval(this.timer);
        this.status = 'end';
        return this.trigger('done');
      };

      Track.prototype.onEnd = function(timer) {
        var endType, gpc, st, vt;
        endType = this.endType;
        gpc = this.gpc;
        switch (endType) {
          case 'stop':
            return this.end();
          case 'stay':
            vt = gpc.getY(this.t);
            st = gpc.getS(this.t);
            this.gpc = F.get('line', 0, vt);
            this.filter.translate([st]);
            this.t = Infinity;
            this.timeCosted = 0;
            return this.trigger('stay');
          case 'repeat':
            this.timeCosted = 0;
            return this.trigger('repeat');
          case 'reverse':
            this.reverse = !this.reverse;
            this.timeCosted = 0;
            return this.trigger('reverse');
          case 'reverse-decay':
            this.reverse = !this.reverse;
            if (!this.reverse) {
              this.filter.decay(0.8);
            }
            this.timeCosted = 0;
            return this.trigger('reverse-decay');
          default:
            if (gpc[endType]) {
              gpc[endType]();
              this.t = gpc.t;
              if (gpc.isEnded) {
                return this.end();
              }
            }
            this.timeCosted = 0;
            return this.trigger(endType);
        }
      };

      return Track;

    })();
    $.extend(Track.prototype, Event);
    return track = {
      get: function(track, opts) {
        var ctl, gpc;
        track = str2arr(track);
        gpc = this.getGpc.apply(this, track);
        ctl = new Track(gpc, opts);
        return ctl;
      },
      getGpc: function(name) {
        var args, gpc;
        args = slice.call(arguments);
        if (type('array', args[0])) {
          if (args.length === 1) {
            args = args[0];
          } else {
            return;
          }
        }
        if (type('string', args[0])) {
          if (!(gpc = Mix.get.apply(Mix, args))) {
            gpc = F.get.apply(F, args);
          }
        }
        return gpc;
      }
    };
  });

}).call(this);
